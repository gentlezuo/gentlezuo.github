---
title: 责任链模式
date: 2019-04-05 16:09:29
tags: 设计模式
category: 设计模式
---

# 责任链模式

## 定义：
是多个对象都有机会处理请求，从而避免了发送者和接收者之间的耦合关系，键这些对象连接成一条链，并沿着这条链传递该请求，直到有一个对象处理它。
<!--more-->

## 结构

Handler：抽象处理器
concreteHandler：具体处理器
Client：客户
## 例子

以大话设计模式中的例子来举例：   
需求：一个员工想要请求一些列的事情，但是处理请求的对象不一致，比如想要请假三天只需要经理批准即可，而如果需要请一个月假那么需要总监批准，如果需要涨薪需要总经理批准。

如果设计一个方法，在方法中进行大量的if else 判断显然不好，职责过大，不符合开闭原则。

我们可以做以下设计来减小耦合：设计一个责任链，在链上的对象如果不处理请求就将请求转发给下一个handler，总会有一个handler处理它

```java
public  class Manage {

    protected Manage next;
    public void setNext(Manage next){
        this.next=next;
    }

    public void handler(Request request){}
}

//经理
public class Jinli extends Manage {
    @Override
    public void handler(Request request){
        if ("请小假".equals(request.getType())){
            System.out.println("批准 "+request.getContext());
        }else {
            super.next.handler(request);
        }
    }
}
//总监
public class Zongjian extends Manage {
    @Override
    public void handler(Request request){
        if ("请大假".equals(request.getType())){
            System.out.println("批准 "+request.getContext());
        }else {
            super.next.handler(request);
        }
    }
}

//总经理
public class Zongjingli extends Manage {
    @Override
    public void handler(Request request){
        if ("涨薪".equals(request.getType())){
            System.out.println("批准 "+request.getContext());
        }else {
            super.next.handler(request);
        }
    }
}

//申请类
public class Request {

    private String type;
    private String context;

    public Request(String type, String context) {
        this.type = type;
        this.context = context;
    }

    ...
}
//实际调用
public class Client {

    public static void main(String[] args) {

        Manage jinli=new Jinli();
        Manage zongjian=new Zongjian();
        Manage zongjinli=new Zongjingli();
        //组装责任链
        jinli.setNext(zongjian);
        zongjian.setNext(zongjinli);

        Request request=new Request("请小假","xxx请3天假");
        jinli.handler(request);
        request.setType("涨薪");
        request.setContext("xxx申请涨薪1000");
        jinli.handler(request);
    }
}

```

类图： 
![](/责任链模式/责任链模式类图.png)

可以看见Manage自关联，而又依赖Request，耦合较轻

## 优点
- 解耦请求者和发送者。
- 简化具体责任对象，因为它不知道链的结构，只要处理自己对应的工作即可。
- 可以动态的增加或者删除责任对象。

## 缺点
- 如果出错，不太容易除错。可能需要到每个具体的责任对象一 一排查。
- 一个责任链需要整个具体责任链对象遍历，然后设置不同的层级。

## 应用
在netty中的ChannelHandler就是用了责任链的变种，转发请求。