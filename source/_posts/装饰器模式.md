---
title: 装饰器模式
date: 2019-04-05 20:29:08
tags: 设计模式
category: 设计模式
---

# 装饰器模式
一般有两种方式可以实现给一个类或对象增加行为：

- 继承机制，使用继承机制是给现有类添加功能的一种有效途径，通过继承一个现有类可以使得子类在拥有自身方法的同时还拥有父类的方法。但是这种方法是静态的，用户不能控制增加行为的方式和时机。
- 关联机制，即将一个类的对象嵌入另一个对象中，由另一个对象来决定是否调用嵌入对象的行为以便扩展自己的行为，我们称这个嵌入的对象为装饰器(Decorator)

## 定义
装饰模式(Decorator Pattern) ：动态地给一个对象增加一些额外的职责(Responsibility)，就增加对象功能来说，装饰模式比生成子类实现更为灵活。它是一种对象结构型模式。

## 结构
- Component:抽象构建，通常是一个接口
- ConcreteComponent: 具体构件（可以被装饰）
- Decorator: 抽象装饰类
- ConcreteDecorator: 具体装饰类
<!--more-->
![装饰器模式](装饰器模式/装饰器模式.png)

## 例子
我有一辆车，想要给它添加不同的功能

Component
~~~java
public interface Car {

}
~~~

具体构建
~~~java
public class MyCar implements Car {
    
}
~~~
装饰类,实现了接口，并持有一个接口对象
~~~java
public class Decorator implements Car {
    Car car;

    public Decorator(Car car) {
        this.car = car;
    }
}
~~~

具体装饰器
~~~java
public class CarFlyDecorator extends Decorator {
    public CarFlyDecorator(Car car) {
        super(car);
    }
    public void fly(){
        System.out.println("fly");
    }
}

~~~
~~~java
public class CarSwimDecortor extends Decorator{
    public CarSwimDecortor(Car car) {
        super(car);
    }
    public void swim(){
        System.out.println("swim");
    }
}
~~~

客户:给指定的车，不同的车增加不同的功能
~~~java

public class Client {
    public static void main(String[] args) {
        Car mycar=new MyCar();
        //想给它添加新功能
        Decorator decorator=new CarFlyDecorator(mycar);
        ((CarFlyDecorator) decorator).fly();

        //想添加其他新功能
        decorator=new CarSwimDecortor(mycar);
        ((CarSwimDecortor) decorator).swim();
    }
}
~~~

## 优点
- 组合比继承更加灵活
- 动态扩展一个类，可以根据配置文件选择不同的装饰器
- 通过使用不同的具体装饰类以及这些装饰类的排列组合，可以创造出很多不同行为的组合

## 缺点
- 产生很多具体装饰类

## 适用环境
- 在不影响其他对象的情况下，以动态、透明的方式给单个对象添加职责。
- 需要动态地给一个对象增加功能，这些功能也可以动态地被撤销。
- 当不能采用继承的方式对系统进行扩充或者采用继承不利于系统扩展和维护时。
- 一个装饰类的接口必须与被装饰类的接口保持相同

参考  
[https://design-patterns.readthedocs.io/zh_CN/latest/structural_patterns/decorator.html](https://design-patterns.readthedocs.io/zh_CN/latest/structural_patterns/decorator.html)