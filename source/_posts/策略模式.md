---
title: 策略模式
date: 2019-04-07 15:03:25
tags: 设计模式
category: 设计模式
---

# 策略模式

- 完成一项任务，往往可以有多种不同的方式，每一种方式称为一个策略，我们可以根据环境或者条件的不同选择不同的策略来完成该项任务。
- 可以定义一些独立的类来封装不同的算法，每一个类封装一个具体的算法，在这里，每一个封装算法的类我们都可以称之为策略(Strategy)，为了保证这些策略的一致性，一般会用一个抽象的策略类来做算法的定义，而具体每种算法则对应于一个具体策略类。

## 定义
策略模式：定义了算法家族，分别封装起来，让他们之间可以相互替换。
<!--more-->
## 结构
- Strategy：抽象策略类
- Context：环境类
- ConcreteStrategy: 具体策略类

## 例子

需求：有三种人到图书馆借书，它们借书的权限不一样，如果是本科生最多借五本，研究生最多借十本，老师最多借二十本并且如果没有此书会给借这本书的学生发信息。

第一种方案：将其逻辑写入一个类中，那么不易变更，不符合开闭原则

第二种方案：抽象三个类代表三种方案

第三种方案：策略模式，将三种算法封装在三个不同的具体策略中，在使用的时候可以实时更换策略达到角色互换，并且易于扩展

Strategy接口
~~~java
//Strategy接口
public interface BorrowStrategy {
    void borrow();
}
~~~

具体策略类
~~~java
public class BorrowForBachlor implements BorrowStrategy {
    private int maxBooks;
    @Override
    public void borrow() {
        ////具体实现逻辑
    }
}



public class BorrowForMaster implements BorrowStrategy {

    private int maxBooks;

    @Override
    public void borrow() {
        ////具体实现逻辑
    }
}



public class BorrowForTeacher implements BorrowStrategy  {

    private int maxBooks;
    public void  borrow(){
       //具体实现逻辑
    }
}
~~~


环境类
~~~java
public class Borrower {
    BorrowStrategy borrowStrategy;
    public Borrower(){}
    public Borrower(BorrowStrategy borrowStrategy) {
        this.borrowStrategy = borrowStrategy;
    }
    public void setBorrowStrategy(BorrowStrategy borrowStrategy) {
        this.borrowStrategy = borrowStrategy;
    }
    public void borrow(){
        borrowStrategy.borrow();
    }
}
~~~

客户类
~~~java

public class Client {
    public static void main(String[] args) {
        Borrower b=new Borrower();
        BorrowForMaster master=new BorrowForMaster();
        //注入策略
        b.setBorrowStrategy(master);
        b.borrow();
        //实时更改
        b.setBorrowStrategy(new BorrowForBachlor());
        b.borrow();
    }

}
~~~

类图：   
![类图](/策略模式/Borrower.png)


就是把具体的算法实现从业务逻辑中剥离出来，成为一系列独立算法类，使得它们可以相互替换。


## 优点
- 不修改原有系统的基础上选择算法或行为，也可以灵活地增加新的算法或行为。

## 缺点
- 客户端必须知道所有的策略类，并自行决定使用哪一个策略类。