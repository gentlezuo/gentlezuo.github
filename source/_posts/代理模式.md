---
title: 代理模式
date: 2019-04-06 15:10:32
tags: 设计模式
category: 设计模式
---

# 代理模式

在某些情况下，一个客户不想或者不能直接引用一个对 象，此时可以通过一个称之为“代理”的第三者来实现 间接引用。代理对象可以在客户端和目标对象之间起到 中介的作用，并且可以通过代理对象去掉客户不能看到 的内容和服务或者添加客户需要的额外服务。（控制被代理的类）

## 定义
代理模式：给某个对象提供一个代理，并由代理对象控制对原对象的引用，是一种对象结构型模式。

<!--more-->

## 结构

- 抽象角色
- 代理角色
- 具体被代理角色

## 代理方法

### 静态代理
创建静态代理类


~~~java
public interface Book {

    void introduce();
}
~~~
实现接口
~~~java
public class MathBookImp implements Book {

    private String name;

    public MathBookImp(String name) {
        this.name = name;
    }

    @Override
    public void introduce() {
        System.out.println("I am "+name);
    }

}
~~~

静态代理类
~~~java

public class StaticProxyBook implements Book {

    public StaticProxyBook(Book book) {
        this.book = book;
    }

    private Book book;
    
    //扩充功能
    @Override
    public void introduce() {
        System.out.println("hhh");
        book.introduce();
        System.out.println("xxx");
    }
    public static void main(String[] args) {
        Book book=new MathBookImp("math");
        StaticProxyBook staticProxyBook=new StaticProxyBook(book);
        staticProxyBook.introduce();
    }

}
~~~
![静态代理](/代理模式/Proxy.png)


### 动态代理
使用反射原理

接口
~~~java
public interface Person {

    void sayHello(String context);
    void sayGoodbye(String contet);

}
~~~

实现InvocationHandler接口  
~~~java


public class MyInvocationHandler implements InvocationHandler {

    Object target;

    public MyInvocationHandler(Object object) {
        this.target = object;
    }

    @Override
    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {

        //first()
        System.out.println("do something before");
        method.invoke(target,args);

        //last()
        System.out.println("do something  last");


        return null;
    }

    public static void main(String[] args) {
        //创建需要被代理的类
        PersonImp personImp=new PersonImp();

        // 创建被代理类的委托类,之后想要调用被代理类的方法时，都会委托给这个类的invoke(Object proxy, Method method, Object[] args)方法
        MyInvocationHandler myInvocationHandler=new MyInvocationHandler(personImp);

        //生成代理类
        Person proxy=(Person) Proxy.newProxyInstance(personImp.getClass().getClassLoader(),
                personImp.getClass().getInterfaces(),
                myInvocationHandler);

        proxy.sayGoodbye("mon");
        proxy.sayGoodbye("dad");


    }

}
~~~

还可以优化,使用泛型

~~~java

/**
 * 使用泛型，封装，更简洁
 */

public class DynamicProxy implements InvocationHandler {

    private Object target;

    public DynamicProxy(Object target) {
        this.target = target;
    }

    @Override
    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
        System.out.println("do something before");
        method.invoke(target,args);
        System.out.println("do something  last");
        return null;
    }

    @SuppressWarnings("unchecked")
    public <T> T getProxy(){

       return (T) Proxy.newProxyInstance(target.getClass().getClassLoader(),target.getClass().getInterfaces(),this);

    }

    public static void main(String[] args) {
        //first example
        PersonImp student =new PersonImp();
        DynamicProxy dp=new DynamicProxy(student);
        Person person=dp.getProxy();
        person.sayHello("good ");

        //second example
        DynamicProxy dp2=new DynamicProxy(new MathBookImp("math"));
        Book book=dp2.getProxy();
        book.introduce();

    }

}
~~~

### cglib

CGlib动态代理是通过继承业务类，生成的动态代理类是业务类的子类，通过重写业务方法进行代理、

## 优点
- 代理模式能够协调调用者和被调用者，在一定程度上降低了系 统的耦合度。
- 保护代理可以控制对真实对象的使用权限。

## 与装饰器模式的区别

代理模式主要是代理类，控制访问被代理类，可以控制真实对象的使用权限。

装饰器模式是增强功能，不能影响原对象的功能。




参考  
[https://design-patterns.readthedocs.io/zh_CN/latest/structural_patterns/proxy.html](https://design-patterns.readthedocs.io/zh_CN/latest/structural_patterns/proxy.html)