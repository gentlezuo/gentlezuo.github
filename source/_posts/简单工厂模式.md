---
title: 简单工厂模式
date: 2019-04-03 19:07:22
tags: 
- 设计模式
category: 设计模式
---

# 简单工厂模式

先复习一下面向对象的七大设计原则。

## 面向对象设计七大原则

<!--more-->
1. 单一职责原则
   - 一个类应该专注于一件事
   - 降低类的复杂性，逻辑简单，提高可读性可维护性，变更影响的风险降低。
2. 里氏替换原则
   - 超类存在的地方，子类可以替换
   - 软件中将一个基类替换为其他的子类对象，不会发生错误，反过来不成立
   - 在程序中应该尽量使用基类类型对子类进行定义，运行时再确定子类类型，使用子类替换父类对象
   - 子类的所有方法必须在父类中声明，或子类必须实现父类中声明的所有方法。尽量把父类设计为抽象类或者接口，让子类继承父类或实现父接口，并实现在父类中声明的方法，运行时，子类实例替换父类实例，我们可以很方便地扩展系统的功能，同时无须修改原有子类的代码，增加新的功能可以通过增加一个新的子类来实现。
3. 依赖倒置原则
   - 尽量依赖抽象，不依赖具体实现
   - 具体依赖抽象，上层依赖下层，假设B是较A低的模块，但B需要使用到A的功能，这个时候，B不应当直接使用A中的具体类；而应当由B定义一抽象接口，并由A来实现这个抽象接口，B只使用这个抽象接口；这样就达到了依赖倒置的目的，B也解除了对A的依赖，反过来是A依赖于B定义的抽象接口。

4. 接口隔离原则
   - 应该为客户端提供较小的单独的接口，而不是提供大的总的接口
   - 建立单一接口，不要建立庞大的接口，尽量细化接口，接口中的方法尽量少。
5. 迪米特法则
   - 最小知识原则，一个软件实体应该尽量与其他实体发生相互作用
   - 类于类之间关系越密切，耦合度越高，应该降低耦合度
6. 开闭原则
   - 面向扩展开放，面向修改关闭
   - 有新的需求或变化时，可以对现有代码进行扩展，以适应新的情况。修改可能造成不好的后果。
7. 聚合、组合复用原则
   - 尽量使用组合，聚合达到复用，少用继承。一个类当中有另一个类的对象。
   - 组合/聚合复用原则可以使系统更加灵活，类与类之间的耦合度降低，一个类的变化对其他类造成的影响相对较少，因此一般首选使用组合/聚合来实现复用


### 例子

#### 单一职责原则：

>当实现一个爬虫的时候，虽然可以把所有的逻辑封装到一个类中，这个类很复杂，可读性差，灵活性也不高，复用性也差（针对不同的的分析提取页面的逻辑都不一样）。当当想要爬取的页面变换的时候，就需要修改整个类；而且复用性差，对每一个爬虫都要写一个庞大的类。
>为了体现单一职责，可以将获取页面的逻辑封装到一个类中，将分析页面数据的类封装到一个类中。这样，页面更改时只需要更改爬取的类；爬取不同的类可以复用爬取的类

#### 里氏替换原则
>子类可以扩展父类的功能，但不能改变父类原有的功能。

- 子类可以实现父类的抽象方法，但是不能覆盖父类的非抽象方法。
- 子类中可以增加自己特有的方法。
- 当子类覆盖或实现父类的方法时，方法的前置条件（即方法的形参）要比父类方法的输入参数更宽松。
- 当子类的方法实现父类的抽象方法时，方法的后置条件（即方法的返回值）要比父类更严格。

#### 依赖倒置原则
>尽量依赖抽象，不依赖具体实现
>比如一个业务模块需要数据访问，业务模块应该依赖接口，数据访问依赖接口，当数据库改变的时候只要接口稳定即可，不需要更改太多代码
>通过引入抽象，对于高层模块而言，低层模块的实现是可替换的。

#### 开闭原则
>当实现一个计算器的类，可以将+-×/各种逻辑封装到不同类中，如果需要添加%功能，不需要更改以前的类，只需要添加一个类即可。

## 简单工厂模式（静态工厂方法）
创建型模式，可以根据参数的不同返回不同类的实例。

当需要获得某个对象时，只需要传入正确的参数就可以获得，不需要关注创建的细节。
### 模式结构
Factory：工厂：负责实现创建所有具体产品类的实例，可以被外界调用。
Product：抽象产品角色：是所有具体产品角色的父类，它负责描述所有实例所共有的公共接口。      
ConcreteProduct：具体产品;继承自抽象产品角色，一般为多个，是简单工厂模式的创建目标。    


![简单工厂模式类图](简单工厂模式/简单工厂uml.png)

举一个例子，一个人想要衣服，只需要给工厂说我需要扫描衣服即可，不需要衣服是怎么来的。  

抽象产品角色
~~~java
public class Clothes {

}
~~~

具体产品类
~~~java
public class ClothesOne extends Clothes{

}
~~~
具体产品类
~~~java
public class ClothesTwo extends Clothes {

}
~~~
工厂类
~~~java
public class Factory {

    public static Clothes getClothes(String name) throws Exception {
        switch (name) {
            case "one":
                return new ClothesOne();
            case "two":
                return new ClothesTwo();
            default:
                throw new Exception("no that clothes");
        }
    }
    
}
~~~
客户想要衣服时
~~~java

public class Client {

    public static void main(String[] args) throws Exception {
        Clothes clothes;
        clothes=Factory.getClothes("one");
        System.out.println(clothes.getClass());//class designPattern.simpleFactory.ClothesOne
        clothes=Factory.getClothes("two");
        System.out.println(clothes.getClass());//class designPattern.simpleFactory.ClothesTwo
    }
}
~~~

![简单工厂模式类图](/简单工厂模式/Example.png)

### 分析：
- 将对象的创建和对象本身业务处理分离可以降低系统的耦合度，使得两者修改起来都相对容易。  
- 在调用工厂类的工厂方法时，由于工厂方法是静态方法，使用起来很方便，可通过类名直接调用，而且只需要传入一个简单的参数即可，在实际开发中，还可以在调用时将所传入的参数保存在XML等格式的配置文件中，修改参数时无须修改任何源代码。   
- 简单工厂模式最大的问题在于工厂类的职责相对过重，增加新的产品需要修改工厂类的判断逻辑，这一点与开闭原则是相违背的。
- 简单工厂模式的要点在于：当你需要什么，只需要传入一个正确的参数，就可以获取你所需要的对象，而无须知道其创建细节。

### 缺点
- 由于工厂类集中了所有产品创建逻辑，一旦不能正常工作，整个系统都要受到影响。
- 使用简单工厂模式将会增加系统中类的个数，在一定程序上增加了系统的复杂度和理解难度。
- 系统扩展困难，一旦添加新产品就不得不修改工厂逻辑，在产品类型较多时，有可能造成工厂逻辑过于复杂，不利于系统的扩展和维护。
- 简单工厂模式由于使用了静态工厂方法，造成工厂角色无法形成基于继承的等级结构。

### 适用场景
- 工厂类负责创建的对象比较少：由于创建的对象较少，不会造成工厂方法中的业务逻辑太过复杂。

### JDK中的体现

Calendar创建不同的对象就是用了静态工厂方法

~~~java
private static Calendar createCalendar(TimeZone zone,
                                           Locale aLocale)
    {
        CalendarProvider provider =
            LocaleProviderAdapter.getAdapter(CalendarProvider.class, aLocale)
                                 .getCalendarProvider();
        if (provider != null) {
            try {
                return provider.getInstance(zone, aLocale);
            } catch (IllegalArgumentException iae) {
                // fall back to the default instantiation
            }
        }

        Calendar cal = null;

        if (aLocale.hasExtensions()) {
            String caltype = aLocale.getUnicodeLocaleType("ca");
            if (caltype != null) {
                switch (caltype) {
                case "buddhist":
                cal = new BuddhistCalendar(zone, aLocale);
                    break;
                case "japanese":
                    cal = new JapaneseImperialCalendar(zone, aLocale);
                    break;
                case "gregory":
                    cal = new GregorianCalendar(zone, aLocale);
                    break;
                }
            }
        }
        if (cal == null) {
            if (aLocale.getLanguage() == "th" && aLocale.getCountry() == "TH") {
                cal = new BuddhistCalendar(zone, aLocale);
            } else if (aLocale.getVariant() == "JP" && aLocale.getLanguage() == "ja"
                       && aLocale.getCountry() == "JP") {
                cal = new JapaneseImperialCalendar(zone, aLocale);
            } else {
                cal = new GregorianCalendar(zone, aLocale);
            }
        }
        return cal;
    }
~~~



参考  
[https://www.cnblogs.com/sunflower627/p/4718702.html](https://www.cnblogs.com/sunflower627/p/4718702.html)  
[https://design-patterns.readthedocs.io/zh_CN/latest/creational_patterns/simple_factory.html](https://design-patterns.readthedocs.io/zh_CN/latest/creational_patterns/simple_factory.html)