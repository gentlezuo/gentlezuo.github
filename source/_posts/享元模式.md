---
title: 享元模式
date: 2019-04-06 14:39:09
tags: 设计模式
category: 设计模式
---
# 享元模式

但在很多情况下需要在系统中增加类和对象的个数。当对象数量太多时，将导致运行代价过高，带来性能下降等问题。享元模式通过共享技术实现相同或相似对象的重用。

- 内部状态：可以共享的相同的内容。
- 外部状态：需要外部设置，不能共享的内容。
- 使用工厂模式维护一个享元池，存储可以共享的享元对象。
- 在实际使用中，能够共享的内部状态是有限的，因此享元对象一般都设计为较小的对象，它所包含的内部状态较少，这种对象也称为细粒度对象。享元模式的目的就是使用共享技术来实现大量细粒度对象的复用。

## 定义
享元模式（FlyWeight）：使用共享技术支持复用大量的细粒度对象。

<!--more-->

## 结构

- 抽象享元类
- 具体享元类
- 非共享具体享元类
- 享元工厂类：创建享元类

## 例子

此时需要共享一个类Fly，但是只能共享100个  

共享类
~~~java
public class Fly {
    private String name;

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public Fly(String name) {
        this.name = name;
    }
}
~~~

静态工厂类
~~~java

public class Factory {
    private static Map<String,Fly> map=new HashMap<>();

    public static Fly getFly(String name){
        if (map.get(name)!=null){
            return map.get(name);
        }
        if (map.size()<100){
            map.put(name,new Fly(name));
            return map.get(name);
        }
        return new Fly(name);
    }
}
~~~

客户类
~~~java

public class Client {
    public static void main(String[] args) {
        for (int i = 0; i <200 ; i++) {
            Factory.getFly(String.valueOf(i));
        }
        Fly fly1=Factory.getFly("1");
        Fly fly2=Factory.getFly("1");
        Fly fly3=Factory.getFly("1000");
        Fly fly4=Factory.getFly("1000");
        System.out.println(fly1==fly2);//true
        System.out.println(fly3==fly4);//false
    }
}
~~~

类图：
![享元模式](/享元模式/Fly.png)

在这个例子中，实际上共享类和非共享类实际上只有一个数量的差别。在JDK中，String，基础类型的包装类都使用了享元模式,-128～127的Integer，Short等都是共享的类。

## 优点

- 减少内存中对象的数量

## 适用环境

- 一个系统有大量相同或者相似的对象，由于这类对象的大量使用，造成内存的大量耗费。
- 对象的大部分状态都可以外部化，可以将这些外部状态传入对象中。
- 使用享元模式需要维护一个存储享元对象的享元池，而这需要耗费资源，因此，应当在多次重复使用享元对象时才值得使用享元模式。


参考   
[https://design-patterns.readthedocs.io/zh_CN/latest/structural_patterns/flyweight.html](https://design-patterns.readthedocs.io/zh_CN/latest/structural_patterns/flyweight.html)   

