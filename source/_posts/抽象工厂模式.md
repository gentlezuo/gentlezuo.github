---
title: 抽象工厂模式
date: 2019-04-04 13:52:15
tags: 
- 设计模式
category: 设计模式
---

# 抽象工厂模式

## 定义
提供一个为创建一系列相关或相互依赖的对象的接口，而无需指定它们具体的类。

概念：  
产品等级概念：产品等级结构即产品的继承结构，如一个抽象类是电视机，其子类有海尔电视机、海信电视机、TCL电视机，则抽象电视机与具体品牌的电视机之间构成了一个产品等级结构，抽象电视机是父类，而具体品牌的电视机是其子类。

产品族 ：在抽象工厂模式中，产品族是指**由同一个工厂生产的**，**位于不同产品等级结构中的一组产品**，如海尔电器工厂生产的海尔电视机、海尔电冰箱，海尔电视机位于电视机产品等级结构中，海尔电冰箱位于电冰箱产品等级结构中。

## 结构
- AbstractFactory：抽象工厂：提供创建产品的接口，创建产品家族。
- ConcreteFactory：具体工厂：实现抽象方法，完成具体产品的创建。
- AbstractProduct：抽象产品
- ConcreteProduct：具体产品
<!--more-->
![抽象工厂模式](抽象工厂模式/抽象工厂模式.jpg)

## 例子

假如要访问一个数据库,刚开始使用Mysql数据库，后来使用Oracle数据库，数据库中有两张表，user，goods 

使用抽象工厂模式，先分析一下：
>接口User，再下一个等级就是MysqlUser，OracleUser；
>接口Goods，再下一个等级就是MysqlGoods，OracleGoods；
>而goods，user在不同的数据库对象中都存在，MysqlUser和MysqlGoods就是一个产品族，OracleUser和OracleGoods也是一个产品族
>定义User，Goods接口；实现后MysqlUser，OracleUser，MySQLGoods，OracleGoods；
>定义AbstractFactory接口，其中有两个创建User和Goods的方法
>实现AbstractFactory，MySQLFactory，OracleFactory；分别用于创建不同的User和Goods；


~~~java
public interface Goods {
    Goods getGoods();
    int setGoods(Goods goods);
}
~~~
~~~java
public interface User {
    User getUser();
    int setUser(User user);
}
~~~

两个不同数据库的user和goods
~~~java

public class MysqlGoods  implements Goods{
    @Override
    public Goods getGoods() {
        Goods goods=new MysqlGoods();//关于Mysql数据库的具体操作
        return goods;
    }

    @Override
    public int setGoods(Goods goods) {
        return 0;
    }
}
~~~
~~~java
public class MysqlUser implements User {
    @Override
    public User getUser() {
        User user=new MysqlUser();//关于Mysql数据库的具体操作
        return user;
    }

    @Override
    public int setUser(User user) {
        return 0;
    }
}
~~~
~~~java
public class OracleGoods implements  Goods{
    @Override
    public Goods getGoods() {
        Goods goods=new OracleGoods();//关于Oracle数据库的具体操作
        return goods;
    }

    @Override
    public int setGoods(Goods goods) {
        return 0;
    }
}

~~~
~~~java
public class OracleUser implements User {

    @Override
    public User getUser() {
        User user=new OracleUser();//关于Oracle数据库的具体操作
        return user;
    }

    @Override
    public int setUser(User user) {
        return 0;
    }
}
~~~
抽象工厂类：用来创建不同的类

~~~java
public interface AbstractFactory {
    User createUser();
    Goods createGoods();
}

~~~
具体工厂类
~~~java
public class MysqlFactory implements AbstractFactory{

    @Override
    public User createUser() {
        return new MysqlUser();
    }

    @Override
    public Goods createGoods() {
        return new MysqlGoods();
    }
}
~~~
~~~java
public class OracleFactory implements AbstractFactory {
    @Override
    public User createUser() {
        return new OracleUser();
    }

    @Override
    public Goods createGoods() {
        return new OracleGoods();
    }
}

~~~
客户端使用
~~~java
public class Client {

    public static void main(String[] args) {
        //使用mysql
        AbstractFactory factory=new MysqlFactory();
        User user=factory.createUser();
        Goods goods=factory.createGoods();
        user.getUser();
        goods.setGoods(goods);
        //使用Oracle数据库，只需要更改一条语句
        factory=new OracleFactory();
        //其他不变
    }
}

~~~

![抽象工厂类图](/抽象工厂模式/AbstractFactory.png)


此时还可以优化：反射机制+配置文件+简单工厂模式

不过增加产品对象依旧需要更改EasyFactory类
~~~java
public class EasyFactory {

    private static final String PACK_NAME="designPattern.abstractFactory";

    private static  String dbName="Mysql";

    public static User createUser() throws Exception {
        String className=PACK_NAME+"."+dbName+"User";
        User user = (User) Class.forName(className).newInstance();
        return user;
    }

    public static Goods createGoods() throws Exception{
        String className=PACK_NAME+"."+dbName+"Goods";
        Goods goods=(Goods) Class.forName(className).newInstance();
        return goods;
    }

    //更改家族
    public static void SetDbName(String name){
        dbName=name;
    }
}
~~~

## 优点
- 抽象工厂模式隔离了具体类的生成，使得客户并不需要知道什么被创建。
- 当一个产品族中的多个对象被设计成一起工作时，它能够保证客户端始终只使用同一个产品族中的对象。

## 缺点
- 在添加新的产品对象时，难以扩展抽象工厂来生产新种类的产品，这是因为在抽象工厂角色中规定了所有可能被创建的产品集合，要支持新种类的产品就意味着要对该接口进行扩展，而这将涉及到对抽象工厂角色及其所有子类的修改，显然会带来较大的不便。比如上述增加一个对象：账单对象，那么就需要更改接口AbstractFactory，增加一个方法，而且在MySQLFactory和OracleFactory中也需要增加方法。
- 增加新的产品等级结构麻烦


参考  
[https://blog.51cto.com/zero01/2070033](https://blog.51cto.com/zero01/2070033)
[https://design-patterns.readthedocs.io/zh_CN/latest/creational_patterns/abstract_factory.html](https://design-patterns.readthedocs.io/zh_CN/latest/creational_patterns/abstract_factory.html)   
