---
title: 建造者模式
date: 2019-04-04 20:07:55
tags: 设计模式
category: 设计模式
---

# 建造者模式

建造者模式：将对象的创建与表示分离，使得同样的建造过程可以创建不同的对象。
<!--more-->
如果需要创建一辆车，车依赖于轮胎，车灯，引擎。有很多中不同的车，创建很麻烦。因此可以将这些创建过程封装。

建造者模式是一步一步创建一个复杂的对象，它允许用户只通过指定复杂对象的类型和内容就可以构建它们，用户不需要知道内部的具体构建细节。建造者模式属于对象创建型模式。

## 结构
- Builder:抽象创建者，规范产品对象的各个组成部分的建造。这个接口规定要实现对象的哪些部分的创建，并不涉及具体的对象部件的创建。
- ConcreteBuilder：具体创建者，继承Builder，针对不同的业务逻辑，具体化对象的各部分的创建。在建造过程完成后，提供产品的实例。
- Director：指挥者，调用具体建造者来创建对象的各个部分，在指导者中不涉及具体产品的信息，只负责保证对象各部分完整创建或按某种顺序创建。
- Product：要创建的产品

![建造者类图](/建造者模式/建造者.png)


## 例子

需要建造一辆车，车子很复杂需要引擎，车灯，轮胎等，需要创建不同的车。

车子
~~~java

public class Car {
    private String eng;
    private String whell;
    private String light;

    public String getEng() {
        return eng;
    }

    public void setEng(String eng) {
        this.eng = eng;
    }

    public String getWhell() {
        return whell;
    }

    public void setWhell(String whell) {
        this.whell = whell;
    }

    public String getLight() {
        return light;
    }

    public void setLight(String light) {
        this.light = light;
    }

    @Override
    public String toString() {
        String s=eng+" "+whell+" "+light;
        return s;
    }
}
~~~



抽象建造者
~~~java
public abstract class Builder {

    abstract void  buildWhell();
    abstract void buildLigth();
    abstract void buildEng();
    abstract Car getCar();

}
~~~


封装第一种车的建造者
~~~java

public class BuildOne extends Builder {
    private Car car=new Car();
    @Override
    void buildWhell() {
        car.setWhell("whell");
    }

    @Override
    void buildLigth() {
        car.setLight("light");
    }

    @Override
    void buildEng() {
        car.setEng("eng");
    }

    @Override
    Car getCar() {
        return car;
    }
}
~~~

封装第二种车的建造者
~~~java

public class BuildTwo extends Builder {
    private Car car=new Car();

    @Override
    void buildWhell() {
        car.setWhell("two whell");
    }

    @Override
    void buildLigth() {
        car.setLight("two light");
    }

    @Override
    void buildEng() {
        car.setEng("two eng");
    }

    @Override
    Car getCar() {
        return car;
    }
}
~~~


指挥者:根据不同的建造者，创建对象，返回对象。
~~~java

public class Director {

    private Builder builder;

    public Director(Builder builder) {
        this.builder = builder;
    }

    public void setBuilder(Builder builder) {
        this.builder = builder;
    }

    public Car construct(){
        builder.buildEng();
        builder.buildWhell();
        builder.buildLigth();
        return builder.getCar();
    }
}

~~~

## 分析

实际上将复杂的建造过程封装，用户不需要知道这东西是怎么来的，由什么组成，只需要了解相应的建造者和指挥者即可。

对于Director类不太理解，construct()也可以添加到Build类也行？

TODO

## 优点
- 在建造者模式中， 客户端不必知道产品内部组成的细节，将产品本身与产品的创建过程解耦，使得相同的创建过程可以创建不同的产品对象。
- 每一个具体建造者都相对独立，而与其他的具体建造者无关，因此可以很方便地替换具体建造者或增加新的具体建造者， 用户使用不同的具体建造者即可得到不同的产品对象。增加新的具体建造者无须修改原有类库的代码。

## 缺点
- 建造者模式所创建的产品一般具有较多的共同点，其组成部分相似，如果产品之间的差异性很大，则不适合使用建造者模式，因此其使用范围受到一定的限制。
- 如果产品的内部变化复杂，可能会导致需要定义很多具体建造者类来实现这种变化，导致系统变得很庞大。

## 使用场景
- 需要生成的产品对象有复杂的内部结构，这些产品对象通常包含多个成员属性。
- 需要生成的产品对象的属性相互依赖，需要指定其生成顺序。

参考   
[https://design-patterns.readthedocs.io/zh_CN/latest/creational_patterns/builder.html](https://design-patterns.readthedocs.io/zh_CN/latest/creational_patterns/builder.html)   

