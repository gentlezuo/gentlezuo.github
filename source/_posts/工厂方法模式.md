---
title: 工厂方法模式
date: 2019-04-04 11:19:33
tags: 
- 设计模式
category: 设计模式
---

# 工厂方法模式
工厂方法模式进一步对简单工厂方法模式进行了抽象，更好地体现了开放封闭原则。属于创建型模式。

## 定义
工厂方法模式又叫工厂模式，虚拟构造器模式，多态工厂模式。

工厂父类/接口负责定义创建产品对象的公共接口，子类工厂对象负责创建具体的产品对象，将产品的实例化交由子类完成，通过子类来确定实例化哪一个对象。实际上利用到了多态（超类对象变量引用子类对象时，被引用对象的类型而不是引用变量的类型决定了调用谁的成员方法，而且这个方法必须在父类中定义过，在子类中复写过，但是它仍然要根据继承链中方法调用的优先级来确认方法）。

## 结构
工厂方法模式包含以下角色：
- Product：抽象产品类
- ConcreteProduct：具体产品类
- Factory：抽象产品类
- ConcreteFactory：具体工厂类
<!--more-->
![工厂方法模式类图](/工厂方法模式/FactoryMethod.jpg)

## 举例
一个人想要获取不同的衣服的场景  
抽象产品类
~~~java

interface ClothesInterface {
    
}
~~~

具体产品类
~~~java
public class ClothesOne implements ClothesInterface { 
    
}
~~~

~~~java
public class ClothesTwo implements ClothesInterface { 
    
}
~~~

抽象工厂了类
~~~java
public interface Factory {
    //定义获取衣服的方法，需要子类区具体实现，并且返回抽象产品类
    Clothes getClothes();
}
~~~
具体工厂类
~~~java
public class FactoryOne implements Factory {
    @Override
    public Clothes getClothes() {
        return new ClothesOne();
    }
}
~~~

~~~java
public class FactoryTwo implements Factory {
    @Override
    public Clothes getClothes() {
        return new ClothesTwo();
    }
}
~~~

客户类：
~~~java
public class Client {
    public static void main(String[] args) throws Exception {
        /*Clothes clothes;
        Factory factory=new FactoryOne();
        clothes=factory.getClothes();
        System.out.println(clothes.getClass());////class designPattern.simpleFactory.ClothesOne
        factory=new FactoryTwo();
        clothes=factory.getClothes();
        System.out.println(clothes.getClass());////class designPattern.simpleFactory.ClothesTwo
        */
        //使用反射
        Clothes clothes;
        Factory factory=(FactoryOne)Class.forName("designPattern.factoryMethod.FactoryOne").newInstance();
        clothes=factory.getClothes();
        System.out.println(clothes.getClass());//class designPattern.simpleFactory.ClothesOne
        factory=(FactoryTwo)Class.forName("designPattern.factoryMethod.FactoryTwo").newInstance();
        clothes=factory.getClothes();//class designPattern.simpleFactory.ClothesTwo
        System.out.println(clothes.getClass());
    }
}
~~~

![类图](/工厂方法模式/MyFactoryMethed.png)


## 优点
- 基于工厂角色和产品角色的多态性设计是工厂方法模式的关键。它能够使工厂可以自主确定创建何种产品对象，而如何创建这个对象的细节则完全封装在具体工厂内部。工厂方法模式之所以又被称为多态工厂模式，是因为所有的具体工厂类都具有同一抽象父类。
- 在系统中加入新产品时，无须修改抽象工厂和抽象产品提供的接口，无须修改客户端，也无须修改其他的具体工厂和具体产品，而只要添加一个具体工厂和具体产品就可以了。这样，系统的可扩展性也就变得非常好，完全符合“开闭原则”。
- 利用面向对象的多态性和里氏代换原则，在程序运行时，子类对象将覆盖父类对象，从而使得系统更容易扩展。

## 缺点
- 在添加新产品时，需要编写新的具体产品类，而且还要提供与之对应的具体工厂类，系统中类的个数将成对增加。