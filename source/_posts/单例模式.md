---
title: 单例模式
date: 2019-04-05 13:16:18
tags: 设计模式
category: 设计模式
---

# 单例模式

单例模式(Singleton Pattern)：单例模式确保某一个类只有一个实例，而且自行实例化并向整个系统提供这个实例，这个类称为单例类，它提供全局访问的方法。属于创建型模式。  

## 结构
Singleton:单例类

## 实现
单例模式的实现有很多种

一般分三步：声明一个私有的静态变量instance；私有化构造方法；提供一个共有的接口用于获取这个对象。
<!--more-->
### 饿汉式（静态常量，线程安全）
懒汉式也就是没有实现延迟加载。

单例模式的一种实现，使用静态常量，在类加载的过程中就已经初始化了INSTANCE这个常量，而类加载只需一次，而且由虚拟机保证线程安全，不过可能浪费系统资源。

~~~java

public class Singleton {
    private static final Singleton INSTANCE=new Singleton();
    private Singleton(){}
    public static Singleton getInstance(){
        return INSTANCE;
    }
}
~~~
### 饿汉式（静态代码块，线程安全）

单例模式的一种实现，依旧没有实现延迟加载，在类加载的过程中就已经执行了静态代码块的内容。

~~~java

public class Singleton1 {
    private static Singleton1 INSTANCE;
    static {
        INSTANCE=new Singleton1();
    }
    public static Singleton1 getInstance(){
        return INSTANCE;
    }
}
~~~

### 懒汉式（线程安全）
单例模式的一种实现，使用synchronized关键字对方法进行加锁，实际上对类进行加锁，不过在并发量较高的情况下效率不是很高。

~~~java

public class Singleton2 {
    private static Singleton2 instance;
    private Singleton2(){}
    public static synchronized Singleton2 getInstance(){
        if(instance==null){
            instance=new Singleton2();
        }
        return instance;
    }
}
~~~

### 懒汉式（线程安全）

单例模式的一种实现，双检查方法

对变量使用volatile关键字修饰：可见性+禁止指令重排序   

如果不加volatile，多个线程调用getInstance()方法，当两个线程都进入到了a,当指令重排序后可能还没与执行new操作，已经释放了锁然后另外一个线程可能进入b


~~~java

public class Singleton3 {
    private static volatile Singleton3 instance;
    private Singleton3(){}
    public static Singleton3 getInstance(){
        if (instance==null){
            //a
            synchronized (Singleton3.class){
                if (instance==null){
                    //b
                    instance=new Singleton3();
                }
            }
        }
        return instance;
    }
}
~~~

### 静态内部类

单例模式的一种实现，使用静态内部类，实际上静态内部类和外部类没有什么关系

当调用getInstance方法时，JVM才会加载内部类，因此实现了延迟加载，而类加载是线程安全的。

~~~java

public class Singleton4 {
    
    private Singleton4() {}
    
    private static class InClass {
        static final Singleton4 INSTANCE = new Singleton4();
    }

    public static Singleton4 getInstance() {
        return InClass.INSTANCE;
    }
}
~~~

### 枚举
~~~java
public enum  Singleton5 {
    INSTANCE;

}
~~~


### CAS
~~~java

/**
 * 单例模式的另一种实现方式：无锁，CAS
 */
public class Singleton6 {
    //需要额外的空间
    private static AtomicReference<Singleton6> singleton=new AtomicReference<>();
    private Singleton6(){

    }
    public static Singleton6 getInstance(){
        for (;;){
            //获取，如果不为空，表示已经有了实例
            Singleton6 instance=singleton.get();
            if (instance!=null){
                return instance;
            }
            //否则，使用cas比较并替换
            instance=new Singleton6();
            if (singleton.compareAndSet(null,instance)){
                return instance;
            }
        }
    }

}
~~~

## 例子
在java中，Runtime这个类就是用了饿汉式单例模式
~~~java
public class Runtime {
    private static Runtime currentRuntime = new Runtime();
    ...
~~~

## 优点
- 提供了对唯一实例的受控访问，为设计及开发团队提供了共享的概念。
- 节约系统资源，对于一些需要频繁创建和销毁的对象，单例模式无疑可以提高系统的性能。
- 允许可变数目的实例。我们可以基于单例模式进行扩展，使用与单例控制相似的方法来获得指定个数的对象实例。

## 适用情况
单例模式适用情况包括：
- 系统只需要一个实例对象；
- 客户调用类的单个实例只允许使用一个公共访问点。


参考  
[https://design-patterns.readthedocs.io/zh_CN/latest/creational_patterns/singleton.html](https://design-patterns.readthedocs.io/zh_CN/latest/creational_patterns/singleton.html)   
[https://www.cnblogs.com/zhaoyan001/p/6365064.html](https://www.cnblogs.com/zhaoyan001/p/6365064.html)   
