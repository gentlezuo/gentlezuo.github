<!DOCTYPE html><html lang="zh-Hans"><head><meta name="generator" content="Hexo 3.8.0"><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="计算机数值表示&amp;Integer"><meta name="keywords" content="java,JDK源码,计算机组成原理"><meta name="author" content="gentlezuo"><meta name="copyright" content="gentlezuo"><title>计算机数值表示&amp;Integer | gentlezuo的博客</title><link rel="shortcut icon" href="/melody-favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.6.1"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.6.1"><link rel="dns-prefetch" href="https://cdn.staticfile.org"><link rel="dns-prefetch" href="https://cdn.bootcss.com"><link rel="dns-prefetch" href="https://creativecommons.org"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  }
} </script></head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar"><div class="toggle-sidebar-info text-center"><span data-toggle="切换文章详情">切换站点概览</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#计算机数值表示-amp-Integer"><span class="toc-number">1.</span> <span class="toc-text">计算机数值表示&amp;Integer</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#原码-反码-补码"><span class="toc-number">1.1.</span> <span class="toc-text">原码 反码 补码</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#为什么在计算机中使用补码"><span class="toc-number">1.1.1.</span> <span class="toc-text">为什么在计算机中使用补码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#将减法转换为加法的正确性证明"><span class="toc-number">1.1.2.</span> <span class="toc-text">将减法转换为加法的正确性证明</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Integer"><span class="toc-number">1.2.</span> <span class="toc-text">Integer</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Short，Long-Byte"><span class="toc-number">1.3.</span> <span class="toc-text">Short，Long,Byte</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Double，Float"><span class="toc-number">1.4.</span> <span class="toc-text">Double，Float</span></a></li></ol></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="https://s2.ax1x.com/2019/03/29/A0hzi6.jpg"></div><div class="author-info__name text-center">gentlezuo</div><div class="author-info__description text-center"></div><div class="follow-button"><a href="https://github.com/gentlezuo">Follow Me</a></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">文章</span><span class="pull-right">4</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">标签</span><span class="pull-right">3</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">分类</span><span class="pull-right">1</span></a></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(https://s2.ax1x.com/2019/03/29/ABlpl9.jpg)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">gentlezuo的博客</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus"><a class="site-page" href="/">Home</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/categories">Categories</a></span></div><div id="post-info"><div id="post-title">计算机数值表示&amp;Integer</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2019-03-30</time><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/java/">java</a><div class="post-meta-wordcount"><span>字数总计: </span><span class="word-count">1.9k</span><span class="post-meta__separator">|</span><span>阅读时长: 8 分钟</span></div></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><h1 id="计算机数值表示-amp-Integer"><a href="#计算机数值表示-amp-Integer" class="headerlink" title="计算机数值表示&amp;Integer"></a>计算机数值表示&amp;Integer</h1><p>在分析Integer类之前，先复习一下在计算机中数值的表示</p>
<h2 id="原码-反码-补码"><a href="#原码-反码-补码" class="headerlink" title="原码 反码 补码"></a>原码 反码 补码</h2><p>借鉴了<a href="https://www.jianshu.com/p/3004e5999be4" target="_blank" rel="noopener">你真的了解补码吗</a></p>
<p>有符号数在计算机中存储，用数的最高位存放符号, 正数为0, 负数为1</p>
<ul>
<li>原码：原码就是符号位加上真值的绝对值，即用第一个二进制位表示符号（正数该位为0，负数该位为1），其余位表示值。</li>
<li>反码：正数的反码与其原码相同；负数的反码是对其原码逐位取反，但符号位除外。</li>
<li>补码：正数的补码就是其本身；负数的补码是在其反码的基础上+1<br>例如：</li>
<li>2 :  00000010（原码），00000010（反码），00000010（补码）</li>
<li>-2:  10000010（原码），11111101（反码），11111110（补码）</li>
</ul>
<p>由补码求源码：</p>
<ul>
<li>如果补码的符号位为“0”，表示是一个正数，所以补码就是该数的原码。 </li>
<li>如果补码的符号位为“1”，表示是一个负数，求原码的操作可以是：符号位为1，其余各位取反，然后再整个数加1。</li>
</ul>
<h3 id="为什么在计算机中使用补码"><a href="#为什么在计算机中使用补码" class="headerlink" title="为什么在计算机中使用补码"></a>为什么在计算机中使用补码</h3><p>对于计算机而言，加减乘数是最基础的运算, 要设计的尽量简单。我们知道，根据运算法则，减去一个正数等于加上一个负数，所以计算机内部可以只有加法而没有减法，将符号位也参与运算，将减法用加法替代。</p>
<p>补码的优点：　　</p>
<ul>
<li>可将减法变为加法，省去减法器；</li>
<li>修复了原码中0的符号(有 [+0] [-0] 之分)以及存在两个编码(0000 0000 和 1000 0000)的问题，而且还能够多表示一个最低数。</li>
</ul>
<p>补码的由来<br>负数的补码时相应的正数取反+1<br>假如一个数是<code>10000110</code>，对应的正数是<code>00000110</code>,该数的补码是：<code>11111010</code><br>可以看做是0-num<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">100000000</span><br><span class="line">-00000110</span><br><span class="line">-----------</span><br><span class="line"> 11111010</span><br></pre></td></tr></table></figure></p>
<p>1 0000 0000 = 1111 1111 + 1<br>因此可以将以上分为两个步骤：按位取反，加1<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> 11111111</span><br><span class="line">-00000110</span><br><span class="line">-------------</span><br><span class="line"> 11111001  +1</span><br><span class="line"> 11111010</span><br></pre></td></tr></table></figure></p>
<h3 id="将减法转换为加法的正确性证明"><a href="#将减法转换为加法的正确性证明" class="headerlink" title="将减法转换为加法的正确性证明"></a>将减法转换为加法的正确性证明</h3><p>已知：X、Y都为正整数，Z = X - Y = X + (-Y)<br>证明：Z = X的补码 + (-Y的补码)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">X的补码 = X; // 正数的补码为其自身</span><br><span class="line">-Y的补码 = (1111 1111 - Y) + 1; // 负数的补码为除符号位的其它位取反加1</span><br><span class="line">Z = X的补码 + (-Y的补码) </span><br><span class="line">  = X +  (1111 1111 - Y) + 1 </span><br><span class="line">  = X - Y + 1 0000 0000</span><br><span class="line">  = X - Y + 0000 0000</span><br><span class="line">  = X - Y</span><br></pre></td></tr></table></figure></p>
<h2 id="Integer"><a href="#Integer" class="headerlink" title="Integer"></a>Integer</h2><p>佩服Lee Boynton，Arthur van Hoff，Josh Bloch，Joseph D. Darcy   </p>
<p>计算机中二进制运算比普通的加减乘除快很多，因此代码中很多使用了位运算，难以阅读，挑选了几个具有代表性的函数分析   </p>
<p>2^n-1是一个神奇的数，在各种场景中都有它的身影，比如hashmap取索引，比如求2^n的mod  </p>
<p>Integer具有缓存机制，当然不止是Integer,包括Long，Byte等</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public final class Integer extends Number implements Comparable&lt;Integer&gt; &#123;</span><br><span class="line"></span><br><span class="line">    @Native public static final int   MIN_VALUE = 0x80000000;</span><br><span class="line"></span><br><span class="line">    @Native public static final int   MAX_VALUE = 0x7fffffff;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line">    public static final Class&lt;Integer&gt;  TYPE = (Class&lt;Integer&gt;) Class.getPrimitiveClass(&quot;int&quot;);</span><br><span class="line"></span><br><span class="line">    private final int value;</span><br></pre></td></tr></table></figure>
<p><code>MIN_VALUE</code>表示最小值-2^31，<code>MAX_VALUE</code>表示最大值2^32-1</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">转换进制</span><br><span class="line">public static String toString(int i, int radix) &#123;</span><br><span class="line">        if (radix &lt; Character.MIN_RADIX || radix &gt; Character.MAX_RADIX)</span><br><span class="line">            radix = 10;</span><br><span class="line"></span><br><span class="line">        /* Use the faster version */</span><br><span class="line">        if (radix == 10) &#123;</span><br><span class="line">            return toString(i);</span><br><span class="line">        &#125;</span><br><span class="line">        //int型的数最长32位，加上符号33位</span><br><span class="line">        char buf[] = new char[33];</span><br><span class="line">        boolean negative = (i &lt; 0);</span><br><span class="line">        int charPos = 32;</span><br><span class="line">        //将所有的数转换为负数，主要是为了统一接下来的计算</span><br><span class="line">        //如果不这样，负数%radix为负数，正数%radix为正数，需要分两种情况判断</span><br><span class="line">        //为什么不转换为正数，因为最小的负数-2^31转换为正数会溢出</span><br><span class="line">        if (!negative) &#123;</span><br><span class="line">            i = -i;</span><br><span class="line">        &#125;</span><br><span class="line">        //开始转换</span><br><span class="line">        while (i &lt;= -radix) &#123;</span><br><span class="line">            buf[charPos--] = digits[-(i % radix)];</span><br><span class="line">            i = i / radix;</span><br><span class="line">        &#125;</span><br><span class="line">        buf[charPos] = digits[-i];</span><br><span class="line"></span><br><span class="line">        if (negative) &#123;</span><br><span class="line">            buf[--charPos] = &apos;-&apos;;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return new String(buf, charPos, (33 - charPos));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>转换为无符号进制数,转换为2^shift进制<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">private static String toUnsignedString0(int val, int shift) &#123;</span><br><span class="line">        // assert shift &gt; 0 &amp;&amp; shift &lt;=5 : &quot;Illegal shift value&quot;;</span><br><span class="line">        //得到除了前导0其他的位数</span><br><span class="line">        int mag = Integer.SIZE - Integer.numberOfLeadingZeros(val);</span><br><span class="line">        //得到最大的长度</span><br><span class="line">        int chars = Math.max(((mag + (shift - 1)) / shift), 1);</span><br><span class="line">        char[] buf = new char[chars];</span><br><span class="line"></span><br><span class="line">        formatUnsignedInt(val, shift, buf, 0, chars);</span><br><span class="line"></span><br><span class="line">        // Use special constructor which takes over &quot;buf&quot;.</span><br><span class="line">        return new String(buf, true);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static int formatUnsignedInt(int val, int shift, char[] buf, int offset, int len) &#123;</span><br><span class="line">        int charPos = len;</span><br><span class="line">        //要转换的进制</span><br><span class="line">        int radix = 1 &lt;&lt; shift;</span><br><span class="line">        //掩码，永远时2^n-1</span><br><span class="line">        int mask = radix - 1;</span><br><span class="line">        //每次得到后shift位，val &amp; mask相当于mod运算！，循环得到结果</span><br><span class="line">        do &#123;</span><br><span class="line">            buf[offset + --charPos] = Integer.digits[val &amp; mask];</span><br><span class="line">            val &gt;&gt;&gt;= shift;</span><br><span class="line">        &#125; while (val != 0 &amp;&amp; charPos &gt; 0);</span><br><span class="line"></span><br><span class="line">        return charPos;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>将一个整数放入字符数值中<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">static void getChars(int i, int index, char[] buf) &#123;</span><br><span class="line">        int q, r;</span><br><span class="line">        int charPos = index;</span><br><span class="line">        char sign = 0;</span><br><span class="line"></span><br><span class="line">        if (i &lt; 0) &#123;</span><br><span class="line">            sign = &apos;-&apos;;</span><br><span class="line">            i = -i;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // Generate two digits per iteration</span><br><span class="line">        while (i &gt;= 65536) &#123;</span><br><span class="line">            q = i / 100;</span><br><span class="line">        // really: r = i - (q * 100);</span><br><span class="line">            r = i - ((q &lt;&lt; 6) + (q &lt;&lt; 5) + (q &lt;&lt; 2));</span><br><span class="line">            i = q;</span><br><span class="line">            //实际上r是一个100以内的数，一次性可以确定两位，根据DigitOnes和DigitTens两个数组</span><br><span class="line">            buf [--charPos] = DigitOnes[r];</span><br><span class="line">            buf [--charPos] = DigitTens[r];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // Fall thru to fast mode for smaller numbers</span><br><span class="line">        // assert(i &lt;= 65536, i);</span><br><span class="line">        for (;;) &#123;</span><br><span class="line">            q = (i * 52429) &gt;&gt;&gt; (16+3);</span><br><span class="line">            r = i - ((q &lt;&lt; 3) + (q &lt;&lt; 1));  // r = i-(q*10) ...</span><br><span class="line">            buf [--charPos] = digits [r];</span><br><span class="line">            i = q;</span><br><span class="line">            if (i == 0) break;</span><br><span class="line">        &#125;</span><br><span class="line">        if (sign != 0) &#123;</span><br><span class="line">            buf [--charPos] = sign;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>求前导0的数量<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public static int numberOfLeadingZeros(int i) &#123;</span><br><span class="line">        // HD, Figure 5-6</span><br><span class="line">        if (i == 0)</span><br><span class="line">            return 32;</span><br><span class="line">        int n = 1;</span><br><span class="line">        //先判断高16位，再判断8位...类似二分法</span><br><span class="line">        if (i &gt;&gt;&gt; 16 == 0) &#123; n += 16; i &lt;&lt;= 16; &#125;</span><br><span class="line">        if (i &gt;&gt;&gt; 24 == 0) &#123; n +=  8; i &lt;&lt;=  8; &#125;</span><br><span class="line">        if (i &gt;&gt;&gt; 28 == 0) &#123; n +=  4; i &lt;&lt;=  4; &#125;</span><br><span class="line">        if (i &gt;&gt;&gt; 30 == 0) &#123; n +=  2; i &lt;&lt;=  2; &#125;</span><br><span class="line">        //判断最高位，若是0，则就是31位，反之30位前导0</span><br><span class="line">        n -= i &gt;&gt;&gt; 31;</span><br><span class="line">        return n;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>求低位第一位为1的值<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public static int lowestOneBit(int i) &#123;</span><br><span class="line">        // HD, Section 2-1</span><br><span class="line">        return i &amp; -i;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>求高为第一位为1的权值<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public static int highestOneBit(int i) &#123;</span><br><span class="line">        // HD, Figure 3-1</span><br><span class="line">        i |= (i &gt;&gt;  1);</span><br><span class="line">        i |= (i &gt;&gt;  2);</span><br><span class="line">        i |= (i &gt;&gt;  4);</span><br><span class="line">        i |= (i &gt;&gt;  8);</span><br><span class="line">        i |= (i &gt;&gt; 16);</span><br><span class="line">        //此时i为11111111...</span><br><span class="line">        return i - (i &gt;&gt;&gt; 1);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>缓存机制：默认缓存范围是-128～127，因此，两个数值在此区间的Ing=teger使用<code>==</code>判断返回的是<code>true</code>，二其他相等范围的Integer则返回false。例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Integer c=55;</span><br><span class="line">Integer d=55;</span><br><span class="line">System.out.println(c==d);(true)</span><br><span class="line">Integer e=999;</span><br><span class="line">Integer f=999;</span><br><span class="line">System.out.println(e==f);(false)</span><br></pre></td></tr></table></figure></p>
<p>源码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">//私有的静态内部类</span><br><span class="line">private static class IntegerCache &#123;</span><br><span class="line">        static final int low = -128;</span><br><span class="line">        static final int high;</span><br><span class="line">        //使用一个数组存储缓存</span><br><span class="line">        static final Integer cache[];</span><br><span class="line"></span><br><span class="line">        //静态代码块，在类加载时期就已经执行了</span><br><span class="line">        static &#123;</span><br><span class="line">            </span><br><span class="line">            int h = 127;</span><br><span class="line">            //用于指定缓冲区的大小</span><br><span class="line">            String integerCacheHighPropValue =</span><br><span class="line">                sun.misc.VM.getSavedProperty(&quot;java.lang.Integer.IntegerCache.high&quot;);</span><br><span class="line">            if (integerCacheHighPropValue != null) &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    int i = parseInt(integerCacheHighPropValue);</span><br><span class="line">                    i = Math.max(i, 127);</span><br><span class="line">                    // Maximum array size is Integer.MAX_VALUE</span><br><span class="line">                    h = Math.min(i, Integer.MAX_VALUE - (-low) -1);</span><br><span class="line">                &#125; catch( NumberFormatException nfe) &#123;</span><br><span class="line">                    // If the property cannot be parsed into an int, ignore it.</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            high = h;</span><br><span class="line"></span><br><span class="line">            cache = new Integer[(high - low) + 1];</span><br><span class="line">            int j = low;</span><br><span class="line">            for(int k = 0; k &lt; cache.length; k++)</span><br><span class="line">                cache[k] = new Integer(j++);</span><br><span class="line"></span><br><span class="line">            </span><br><span class="line">            assert IntegerCache.high &gt;= 127;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        private IntegerCache() &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">//如果数值在缓存范围，获取的就是缓存的对象，而非重新new</span><br><span class="line">public static Integer valueOf(int i) &#123;</span><br><span class="line">        if (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)</span><br><span class="line">            return IntegerCache.cache[i + (-IntegerCache.low)];</span><br><span class="line">        return new Integer(i);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="Short，Long-Byte"><a href="#Short，Long-Byte" class="headerlink" title="Short，Long,Byte"></a>Short，Long,Byte</h2><p>这些类与Integer相似，只是范围不同，它们也有缓存机制，范围都是-128～127，并且不可更改</p>
<h2 id="Double，Float"><a href="#Double，Float" class="headerlink" title="Double，Float"></a>Double，Float</h2><p>注意：是允许1/0,-1/0,0/0的,其他类型都不允许</p>
<p>例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Double a=-1.0/0.0+100;</span><br><span class="line">Double b=1.0/0.0;</span><br><span class="line">Double c=0.0/0.0;</span><br><span class="line"></span><br><span class="line">System.out.println(a);  ( -Infinity )</span><br><span class="line">System.out.println(b);  ( Infinity )</span><br><span class="line">System.out.println(c);  ( NaN )</span><br></pre></td></tr></table></figure></p>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">gentlezuo</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://gentlezuo.github.io/2019/03/30/计算机数值表示-Integer/">http://gentlezuo.github.io/2019/03/30/计算机数值表示-Integer/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://gentlezuo.github.io">gentlezuo的博客</a>！</span></div></div><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/java/">java</a><a class="post-meta__tags" href="/tags/JDK源码/">JDK源码</a><a class="post-meta__tags" href="/tags/计算机组成原理/">计算机组成原理</a></div><nav id="pagination"><div class="next-post pull-right"><a href="/2019/03/30/JDK-String相关/"><span>JDK-String相关</span><i class="fa fa-chevron-right"></i></a></div></nav></div></div><footer class="footer-bg" style="background-image: url(https://s2.ax1x.com/2019/03/29/ABlpl9.jpg)"><div class="layout" id="footer"><div class="copyright">&copy;2019 By gentlezuo</div><div class="framework-info"><span>驱动 - </span><a href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 - </span><a href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file-o"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.6.1"></script><script src="/js/fancybox.js?version=1.6.1"></script><script src="/js/sidebar.js?version=1.6.1"></script><script src="/js/copy.js?version=1.6.1"></script><script src="/js/fireworks.js?version=1.6.1"></script><script src="/js/transition.js?version=1.6.1"></script><script src="/js/scroll.js?version=1.6.1"></script><script src="/js/head.js?version=1.6.1"></script><script>if(/Android|webOS|iPhone|iPod|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
}</script></body></html>